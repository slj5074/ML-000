# -*- coding: utf-8 -*-
"""hw01

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dl5oYdyAfGZi2BFuV19KPhv5H_5CEZdU
"""

from google.colab import drive
drive.mount('/gdrive')

!git clone https://github.com/slj5074/ml-training-camp.git

import numpy as np
import pandas as pd

def target_mean_v1(data, y_name, x_name):
    result = np.zeros(data.shape[0])
    for i in range(data.shape[0]):
        groupby_result = data[data.index != i].groupby([x_name], as_index=False).agg(['mean', 'count'])
        result[i] = groupby_result.loc[groupby_result.index == data.loc[i, x_name], (y_name, 'mean')]
    return result

def target_mean_v2(data, y_name, x_name):
    result = np.zeros(data.shape[0])
    value_dict = dict()
    count_dict = dict()
    for i in range(data.shape[0]):
        if data.loc[i, x_name] not in value_dict.keys():
            value_dict[data.loc[i, x_name]] = data.loc[i, y_name]
            count_dict[data.loc[i, x_name]] = 1
        else:
            value_dict[data.loc[i, x_name]] += data.loc[i, y_name]
            count_dict[data.loc[i, x_name]] += 1
    for i in range(data.shape[0]):
        result[i] = (value_dict[data.loc[i, x_name]] - data.loc[i, y_name]) / (count_dict[data.loc[i, x_name]] - 1)
    return result

y = np.random.randint(2, size=(5000, 1))
x = np.random.randint(10, size=(5000, 1))
data = pd.DataFrame(np.concatenate([y, x], axis=1), columns=['y', 'x'])

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# result_1 = target_mean_v1(data, 'y', 'x')

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# result_2 = target_mean_v2(data, 'y', 'x')

# Commented out IPython magic to ensure Python compatibility.
# %load_ext Cython

# Commented out IPython magic to ensure Python compatibility.
# %%cython --cplus
# cimport numpy as cnp
# from libcpp.vector cimport vector
# 
# cpdef target_mean_v3(data, y_name, x_name):
# 
#     cdef dict value_dict = {}
#     cdef dict count_dict = {}
#     cdef int n = data.shape[0]
# 
#     cdef vector[double] result
#     result.reserve(n)
# 
#     for i in range(n):
#         if data.loc[i, x_name] not in value_dict.keys():
#             value_dict[data.loc[i, x_name]] = data.loc[i, y_name]
#             count_dict[data.loc[i, x_name]] = 1
#         else:
#             value_dict[data.loc[i, x_name]] += data.loc[i, y_name]
#             count_dict[data.loc[i, x_name]] += 1
# 
#     for i in range(n):
#         result.push_back((value_dict[data.loc[i, x_name]] - data.loc[i, y_name]) / (count_dict[data.loc[i, x_name]] - 1))
#     return result

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# result_3 = target_mean_v3(data, 'y', 'x')